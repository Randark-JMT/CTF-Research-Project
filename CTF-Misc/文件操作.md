# Misc-文件操作

说是Misc手的基本功，简单而基础。

## 一、文件识别

对于位置文件的类型的识别，有多种姿势：

### 1. file指令

Linux系统下，可以使用`file`指令来识别文件格式。Linux系统内部储存了大量的文件幻数的数据，基本上可以做到精准识别。

比如，用.scr文件举例（这是Windows屏保文件）：

```shell
┌──(kali㉿kali)-[~]
└─$ file Fliqlo.scr              
Fliqlo.scr: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windows
```

### 2. 人工识别

利用`WinHEX`、`010 Editor`等十六进制工具打开位置文件，可以看到文件的十六进制的数据，进而通过对比文件幻数表，可以读取出文件类型。

![以010 Editor举例](../CTF-images/image-20220112081119904.png)

同时，`010 Editor`的模板功能也可以让用户核对文件结构，并发现潜在的数据结构错误。（模板功能的实现依赖于文件的扩展名，故被恶意修改扩展名的文件，是没有办法被成功被模板识别的）

## 二、文件修复

这块内容比较玄学了。。列出目前我遇到过的情况：

-   文件头篡改成其他文件头：根据题目和文件结构尝试所有可能性
-   文件数据颠倒写入：用脚本将文件数据再颠倒回来
-   文件部分关键数据位篡改：比如jpg文件的高，UPX加壳后的`UPX`标记位，等等。根据特征尝试修复。

## 三、文件合并与分离

### 1. 文件合并

#### copy

这个指令适用于Windows平台，附上help信息：

```shell
> help copy
将一份或多份文件复制到另一个位置。

COPY [/D] [/V] [/N] [/Y | /-Y] [/Z] [/L] [/A | /B ] source [/A | /B]
     [+ source [/A | /B] [+ ...]] [destination [/A | /B]]

  source       指定要复制的文件。
  /A           表示一个 ASCII 文本文件。
  /B           表示一个二进位文件。
  /D           允许解密要创建的目标文件
  destination  为新文件指定目录和/或文件名。
  /V           验证新文件写入是否正确。
  /N           复制带有非 8dot3 名称的文件时，
               尽可能使用短文件名。
  /Y           不使用确认是否要覆盖现有目标文件
               的提示。
  /-Y          使用确认是否要覆盖现有目标文件
               的提示。
  /Z           用可重新启动模式复制已联网的文件。
  /L           如果源是符号链接，请将链接复制
               到目标而不是源链接指向的实际文件。

命令行开关 /Y 可以在 COPYCMD 环境变量中预先设定。
这可能会被命令行上的 /-Y 替代。除非 COPY
命令是在一个批处理脚本中执行的，默认值应为
在覆盖时进行提示。

要附加文件，请为目标指定一个文件，为源指定
数个文件(用通配符或 file1+file2+file3 格式)。
```

举个例子，比如将文件夹内的所有ts文件合并为一个ts文件，就可以用一条指令操作：

```shell
copy  /b  E:\testts\temp\*.ts  E:\testts\final\final.ts
```

#### cat

cat指令原本在Linux下，只是一个读取文件数据，并打印在输出流（比如命令行里面）的命令，但由于Linux中，可以通过`>`符号重定向输出流，使得cat指令也具有了合并文件的能力。举个例子：

```shell
cat db1.sql db2.sql db3.sql > db_all.sql
```

这个指令就是将``db1.sql` 、`db2.sql`、 `db3.sql`三个文件的数据输出到输出流，然后`> db_all.sql`重定向输出流到`db_all.sql`这个文件，也就实现了文件合并的操作。

### 2.文件分离

说实话，这一块你啥姿势都可以，甚至用Python实现都可以（详见我写的伪加密自动处理脚本）。这里只列出常见的文件分离的姿势：

#### foremost & binwalk

`foremost`和`binwalk`两个都是Misc手的老朋友了，常常用于自动化分离附加文件和固件数据分析中。`binwalk`用Python编写，其灵敏度大，生成的报告详细，用于捕捉一切可能数据，但在内存分析这类模块，反而会因为过于敏感，而找不到关键数据。`foremost`最初由美国空军特别调查办公室和信息系统安全研究中心开发，后来向公众开放。一款老牌的固件分析工具，也被用来处理文件附加数据。其灵敏度低，注重于敏感格式数据的提取，使得其在内存分析和固件分析领域屹立不倒。

常用姿势：

```shell
$ foremost ***.*** #输出文件内所有可能数据到./output文件夹
$ binwalk ***.*** #打印分析结果
$ binwalk -e ***.*** #输出所有可能数据到一个新文件夹
```

#### dd

当上面两个工具分离出错或者无法自动分离时，就需要dd来手动实现分离。命令格式：

```shell
dd if=源文件 of=目标文件名  bs=5（我要取前面五个字符，块就为5 ） count=1（去1块） skip= 开始分离的字节

参数说明；
if = 输入文件名 缺省为标准输入
of = 分离后的文件名    分离后的文件名
bs =  将文件分为多个块，一个块的大小为字节为i（bs=bytes）
count =  从头开始取j块
skip= 在输入开始处跳过指定的 ibs 大小的块数
命令表示：截取源文件，开始字段为i X k，截取字段的长度为i X j 当skip省略时，截取从0开始，截取字段的长度为i X j
```

#### HEX Editor

比如`WinHEX`、`010 Editor`这类工具，既然可以查看文件的十六进制数据，那么自然也可以编辑文件数据。这里不加以赘述。



