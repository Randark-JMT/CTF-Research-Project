# 常见加密算法及编码识别

> Reverse这种题目，怎么可能会让你直接IDA，然后<kbd>Shift</kbd>+<kbd>F12</kbd>，那不就变成了手速抢分题XD

这里只讨论常见加密算法和编码的识别逻辑，脱壳和花指令另外讨论。

另外，一般在Reverse中，为了得到正确数据，要么动调，要么则静态分析，并且大多时候会另外写一套等效代码来复现过程。但是在C中，`char`出来的对象是可以修改的，比如：

```c++
strinng[i] += 1
```

但是一般为了方便和便于分析，有些时候会使用Python编写等效逻辑，这时则需要注意Python中字符串为不可修改的对象，需要`ord()`先输出为一个列表，再进行修改。

例如以下c代码：

```c
#include<stdio.h>
int main()
{
    char strings[11]={"hello word"};
    printf("%s\n",strings);
    for(int i=0;i<=11;i++)
    {
        strings[i]+=1;
    }
    printf("%s",strings);
    return 0;
}
```

在C这类弱类型的语言中，`int`和`char`两个类型的可以泛用，而若用Python写等效逻辑，那么编写的时候不能直接修改字符串数据，需要先转换为列表：

```python
s="hello word"
s_raw=[]
print(s)
for letter in s:
    s_raw.append(ord(letter)+1)
for letter in s_raw:
    print(chr(letter),end="")
```

## Base64

> Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。转换的时候，将 3 字节的数据，先后放入一个 24 位的缓冲区中，先来的字节占高位。数据不足 3 字节的话，于缓冲器中剩下的比特用 0 补足。每次取出 6 比特（因为2^6=64)，按照其值选择`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/`中的字符作为编码后的输出，直到全部输入数据转换完成。

注意，Base64，乃至于Base家族，本身都不是一种加密算法，而是一种编码算法。对于Base64，识别其算法的核心在于：

1. 在程序中发现一串字符串，涉及大量字母和数字，并且其中没有重复项（一一对应的原则），正常的索引表应当为：
   
   ```text
   ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
   ```

2. 在程序中，存在判断逻辑结构，并且case对应值分别为：1、2、3。这对应着索引表的索引逻辑

3. 发现程序中存在针对不同情况而存在数据移位动作。（不常用，并且存在其它编码/加密的可能性）

对于Base家族的编解码，建议使用Python运算，因为Python中存在已有的Base家族的运行库，编写脚本的时候更方便。如果是正常的索引表，更可以尝试使用[mufeedvh/basecrack](https://github.com/mufeedvh/basecrack)来对编码后的数据进行所有Base家族可能编码的检测和解密。

### 例题

#### [BUUCTF-reverse3](https://buuoj.cn/challenges#reverse3)

*-->这是一道正常的Base64逆向*

程序下载分析，无壳，32-bits，直接进IDA逆向，看一下主函数：

```c
int __cdecl main_0(int argc, const char **argv, const char **envp)
{
  size_t v3;             // eax
  const char *v4;        // eax
  size_t v5;             // eax
  char v7;               // [esp+0h] [ebp-188h]
  char v8;               // [esp+0h] [ebp-188h]
  signed int j;          // [esp+DCh] [ebp-ACh]
  int i;                 // [esp+E8h] [ebp-A0h]
  signed int v11;        // [esp+E8h] [ebp-A0h]
  char Destination[108]; // [esp+F4h] [ebp-94h] BYREF
  char Str[28];          // [esp+160h] [ebp-28h] BYREF
  char v14[8];           // [esp+17Ch] [ebp-Ch] BYREF
  // 变量初始化

  for (i = 0; i < 100; ++i)
  {
    if ((unsigned int)i >= 0x64)
      j____report_rangecheckfailure(); //检查堆栈缓存溢出
    Destination[i] = 0;
  }
  sub_41132F("please enter the flag:", v7); // sub_41132F --> printf
  sub_411375("%20s", (char)Str);            // sub_411375 --> scanf
  //输出并捕获输入，输入的数据储存到Str

  v3 = j_strlen(Str);
  v4 = (const char *)sub_4110BE(Str, v3, v14);
  strncpy(Destination, v4, 0x28u);
  //用sub_4110BE处理Str的数据，并将处理过的数据 --> v4 --> Destination
  v11 = j_strlen(Destination);
  for (j = 0; j < v11; ++j)
    Destination[j] += j;
  v5 = j_strlen(Destination);
  //对Destination的数据进行类变异凯撒处理
  if (!strncmp(Destination, Str2, v5))
    sub_41132F("rigth flag!\n", v8);
  else
    sub_41132F("wrong flag!\n", v8);
  return 0;
}
```

接着看`sub_4110BE`函数，看一下加密逻辑：

```c
// attributes: thunk
int __cdecl sub_4110BE(int a1, int a2, int a3)
{
  return sub_411AB0(a1, a2, a3);
}
```

跟进下去：

```c
void *__cdecl sub_411AB0(char *a1, unsigned int a2, int *a3)
{
  int v4; // [esp+D4h] [ebp-38h]
  int v5; // [esp+D4h] [ebp-38h]
  int v6; // [esp+D4h] [ebp-38h]
  int v7; // [esp+D4h] [ebp-38h]
  int i; // [esp+E0h] [ebp-2Ch]
  unsigned int v9; // [esp+ECh] [ebp-20h]
  int v10; // [esp+ECh] [ebp-20h]
  int v11; // [esp+ECh] [ebp-20h]
  void *v12; // [esp+F8h] [ebp-14h]
  char *v13; // [esp+104h] [ebp-8h]

  if ( !a1 || !a2 ) //检查传入的数据
    return 0;
  v9 = a2 / 3;
  if ( (int)(a2 / 3) % 3 )
    ++v9;
  v10 = 4 * v9;
  *a3 = v10;
  v12 = malloc(v10 + 1); //内存分配函数
  if ( !v12 )
    return 0;
  j_memset(v12, 0, v10 + 1); //内存分配
  v13 = a1;
  v11 = a2;
  v4 = 0;
  while ( v11 > 0 )
  {
    byte_41A144[2] = 0;
    byte_41A144[1] = 0;
    byte_41A144[0] = 0;
    for ( i = 0; i < 3 && v11 >= 1; ++i )
    {
      byte_41A144[i] = *v13;
      --v11;
      ++v13;
    }
    if ( !i )
      break;
    switch ( i ) //根据索引值从索引表中提取数据，并储存
    {
      case 1:
        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] >> 2];
        v5 = v4 + 1;
        *((_BYTE *)v12 + v5) = aAbcdefghijklmn[((byte_41A144[1] & 0xF0) >> 4) | (16 * (byte_41A144[0] & 3))];
        *((_BYTE *)v12 + ++v5) = aAbcdefghijklmn[64];
        *((_BYTE *)v12 + ++v5) = aAbcdefghijklmn[64];
        v4 = v5 + 1;
        break;
      case 2:
        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] >> 2];
        v6 = v4 + 1;
        *((_BYTE *)v12 + v6) = aAbcdefghijklmn[((byte_41A144[1] & 0xF0) >> 4) | (16 * (byte_41A144[0] & 3))];
        *((_BYTE *)v12 + ++v6) = aAbcdefghijklmn[((byte_41A144[2] & 0xC0) >> 6) | (4 * (byte_41A144[1] & 0xF))];
        *((_BYTE *)v12 + ++v6) = aAbcdefghijklmn[64];
        v4 = v6 + 1;
        break;
      case 3:
        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] >> 2];
        v7 = v4 + 1;
        *((_BYTE *)v12 + v7) = aAbcdefghijklmn[((byte_41A144[1] & 0xF0) >> 4) | (16 * (byte_41A144[0] & 3))];
        *((_BYTE *)v12 + ++v7) = aAbcdefghijklmn[((byte_41A144[2] & 0xC0) >> 6) | (4 * (byte_41A144[1] & 0xF))];
        *((_BYTE *)v12 + ++v7) = aAbcdefghijklmn[byte_41A144[2] & 0x3F];
        v4 = v7 + 1;
        break;
    }
  }
  *((_BYTE *)v12 + v4) = 0;
  return v12;
}
```

并且看一下`aAbcdefghijklmn`的数据：

```c
.rdata:00417B30 aAbcdefghijklmn db 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
```

关键点：

1. `sub_411AB0`的运算逻辑符合`Base64`的运算法则

2. <kbd>Shift</kbd>+<kbd>F12</kbd>可以看到字符串列表里面存在索引表：`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=`

那么可以确定这个程序是对输入的数据进行`Base64`编码，然后进行一次变异凯撒加密，最后与`Str2`进行校验。并且找到编码后的数据：

```c
.data:0041A034 Str2            db 'e3nifIH9b_C@n@dH',0 ; DATA XREF: _main_0+142↑o
```

于是逆逻辑编写Python脚本解密：

```python
import base64
final='e3nifIH9b_C@n@dH'
final_raw=[]
for letter in final:
    final_raw.append(ord(letter))
i:int=0
while i<len(final_raw):
    final_raw[i]-=i
    i+=1
s_raw=""
for letter in final_raw:
    s_raw+=chr(letter)
print(base64.b64decode(s_raw).decode())
```

得到输出：

```text
{i_l0ve_you}
```

#### [BUUCTF-特殊的 BASE64](https://buuoj.cn/challenges#%E7%89%B9%E6%AE%8A%E7%9A%84%20BASE64)

*-->这是一道索引表被更改的Base64逆向*，但是本身Base64编码的逻辑没有变化

程序下载分析，无壳，64-bits，直接进IDA逆向，看一下主函数：

```c++
int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int64 v3; // rax
  __int64 v4; // rax
  std::string result; // [rsp+20h] [rbp-60h] BYREF
  std::string rightFlag; // [rsp+30h] [rbp-50h] BYREF
  std::string str; // [rsp+40h] [rbp-40h] BYREF
  char v9; // [rsp+4Fh] [rbp-31h] BYREF
  std::string v10; // [rsp+50h] [rbp-30h] BYREF
  //变量初始化
  _main();
  std::string::string(&str);
  std::allocator<char>::allocator(&v9);
  std::string::string(&rightFlag, "mTyqm7wjODkrNLcWl0eqO8K8gc1BPk1GNLgUpI==", &v9);
  std::allocator<char>::~allocator(&v9);
  //储存了可疑密文
  v3 = std::operator<<<std::char_traits<char>>(refptr__ZSt4cout, "Please input your flag!!!!");
  std::ostream::operator<<(v3, refptr__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_);
  //输出，并捕获输入
  std::operator>><char>(refptr__ZSt3cin, &str);
  std::string::string(&v10, &str);
  base64Encode(&result);
  //Base64加密函数
  std::string::~string(&v10);
  if ( std::operator==<char>(&result, &rightFlag) )
    v4 = std::operator<<<std::char_traits<char>>(refptr__ZSt4cout, "The flag is right!!!!!!!!!");
  else
    v4 = std::operator<<<std::char_traits<char>>(refptr__ZSt4cout, "This is a wrong flag!!!!!!!!");
  //判断输入是否正确，并输出结果
  std::ostream::operator<<(v4, refptr__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_);
  std::string::~string(&result);
  std::string::~string(&rightFlag);
  std::string::~string(&str);
  return 0;
}
```

很明显，这是一个c++写的程序，并且带有密文：

```text
mTyqm7wjODkrNLcWl0eqO8K8gc1BPk1GNLgUpI==
```

但是对这串密文采用Basecrack，返回非Base加密。于是在分析主函数后，跟进到加密函数`base64Encode`：

```c++
std::string __cdecl base64Encode(std::string *p_decode)
{
  std::string *v1; // rdx
  char *v2; // rax
  int v3; // ebx
  char *v4; // rax
  int v5; // ebx
  char *v6; // rax
  _BYTE *v7; // rax
  char *v8; // rax
  _BYTE *v9; // rax
  char *v10; // rax
  int v11; // ebx
  char *v12; // rax
  _BYTE *v13; // rax
  __int64 v15; // [rsp+0h] [rbp-80h] BYREF
  char v16; // [rsp+2Fh] [rbp-51h] BYREF
  int pos_0; // [rsp+30h] [rbp-50h]
  int pos; // [rsp+34h] [rbp-4Ch]
  int len; // [rsp+38h] [rbp-48h]
  int i; // [rsp+3Ch] [rbp-44h]
  std::string *p_decodea; // [rsp+68h] [rbp-18h]

  p_decodea = v1;
  std::allocator<char>::allocator((char *)&v15 + 47);
  std::string::string(p_decode, &unk_489084, &v16);
  std::allocator<char>::~allocator(&v16);
  len = std::string::length(p_decodea);
  for ( i = 0; len / 3 > i; ++i )
  {
    v2 = (char *)std::string::operator[](p_decodea, 3 * i);
    std::string::operator[](&baseKey, *v2 >> 2);
    std::string::operator+=(p_decode);
    v3 = 16 * (*(_BYTE *)std::string::operator[](p_decodea, 3 * i) & 3);
    v4 = (char *)std::string::operator[](p_decodea, 3 * i + 1);
    std::string::operator[](&baseKey, v3 | (*v4 >> 4));
    std::string::operator+=(p_decode);
    v5 = 4 * (*(_BYTE *)std::string::operator[](p_decodea, 3 * i + 1) & 0xF);
    v6 = (char *)std::string::operator[](p_decodea, 3 * i + 2);
    std::string::operator[](&baseKey, v5 | (*v6 >> 6));
    std::string::operator+=(p_decode);
    v7 = (_BYTE *)std::string::operator[](p_decodea, 3 * i + 2);
    std::string::operator[](&baseKey, *v7 & 0x3F);
    std::string::operator+=(p_decode);
  }
  if ( len % 3 == 1 )
  {
    pos = 3 * (len / 3);
    v8 = (char *)std::string::operator[](p_decodea, pos);
    std::string::operator[](&baseKey, *v8 >> 2);
    std::string::operator+=(p_decode);
    v9 = (_BYTE *)std::string::operator[](p_decodea, pos);
    std::string::operator[](&baseKey, 16 * (*v9 & 3));
    std::string::operator+=(p_decode);
    std::string::operator+=(p_decode, "==");
  }
  if ( len % 3 == 2 )
  {
    pos_0 = 3 * (len / 3);
    v10 = (char *)std::string::operator[](p_decodea, pos_0);
    std::string::operator[](&baseKey, *v10 >> 2);
    std::string::operator+=(p_decode);
    v11 = 16 * (*(_BYTE *)std::string::operator[](p_decodea, pos_0) & 3);
    v12 = (char *)std::string::operator[](p_decodea, pos_0 + 1);
    std::string::operator[](&baseKey, v11 | (*v12 >> 4));
    std::string::operator+=(p_decode);
    v13 = (_BYTE *)std::string::operator[](p_decodea, pos_0 + 1);
    std::string::operator[](&baseKey, 4 * (*v13 & 0xF));
    std::string::operator+=(p_decode);
    std::string::operator+=(p_decode, "=");
  }
  return (std::string)p_decode;
}
```

对数据的处理逻辑符合Base64，但是还需跟进索引表，检查索引表是否正常：

```c++
.rdata:0000000000489090 aAabbccddeeffgg db 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0987654321/+',0
```

那么就很明显了，这块是Base64编码，但是索引表被替换为其它索引表。

那么首先考虑根据索引表将编码后的数据恢复为正常的Base64编码的数据，然后直接利用Python已有的Base64库来进行解密：

```python
import base64
str1 = "mTyqm7wjODkrNLcWl0eqO8K8gc1BPk1GNLgUpI=="
dic_1 = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0987654321/+"
dic_2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
a = str1.translate(str.maketrans(dic_1, dic_2))  
# 这一步将两个索引表的数据进行对照，将编码后的数据进行转换，还原成正常base64编码后的密文
print(base64.b64decode(a).decode())  # base64解码
```

得到输出：

```text
flag{Special_Base64_By_Lich}
```

## TEA

> 在安全学领域，TEA（Tiny Encryption Algorithm）是一种分组加密算法，它的实现非常简单，通常只需要很精短的几行代码。TEA 算法最初是由剑桥计算机实验室的 David Wheeler 和 Roger Needham 在 1994 年设计的。
> TEA算法使用64位的明文分组和128位的密钥，它使用Feistel分组加密框架，需要进行 64 轮迭代，尽管作者认为 32 轮已经足够了。该算法使用了一个神秘常数δ作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但δ的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」（也就是程序中的 0×9E3779B9）。

### 示例代码

```c
#include <stdint.h>
void encrypt (uint32_t* v, uint32_t* k) {
    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */
    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */
    //分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组
    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */
    //总共加密32轮
    for (i=0; i < 32; i++) {                       /* basic cycle start */
        sum += delta;
        v0 += ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);
        v1 += ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);  
    }                                              /* end cycle */
    //最后加密的结果重新写入到数组中
    v[0]=v0; v[1]=v1;
}
void decrypt (uint32_t* v, uint32_t* k) {
    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */
    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */
    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */
    for (i=0; i<32; i++) {                         /* basic cycle start */
        v1 -= ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);
        v0 -= ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);
        sum -= delta;                                   
    }                                              /* end cycle */
    v[0]=v0; v[1]=v1;
}
```

以及在Python的实现：

```python
import ctypes
def encrypt_TEA(v, k):
    y = c_int32(v[0])
    z = c_int32(v[1])
    sum = c_int32(0)
    delta = 0x9e3779b9
    n = 16
    w = [0, 0]
    while n > 0:
        y.value += z.value << 4 ^ z.value >> 5 + sum.value ^ z.value + k[sum.value & 3]
        sum.value -= delta
        z.value += y.value << 4 ^ y.value >> 5 + sum.value ^ y.value + k[sum.value >> 11 & 3]
        n -= 1
    w[0]=y.value
    w[1]=z.value
    return w
```

建议加解密使用C来实现，python有点复杂。Python下如果int的数据过长，Python会自动把int转换为long，就导致运算结果与C中的不一致。

### 例题

#### GWCTF 2019 xxor

[[GWCTF 2019]xxor](https://buuoj.cn/challenges#%5BGWCTF%202019%5Dxxor)

附件下载分析，ELF文件，无壳，64-bits，IDA逆向，看一下入口：

```c
__int64 __fastcall main(int a1, char **a2, char **a3)
{
  int i; // [rsp+8h] [rbp-68h]
  int j; // [rsp+Ch] [rbp-64h]
  __int64 v6[6]; // [rsp+10h] [rbp-60h] BYREF
  __int64 v7[6]; // [rsp+40h] [rbp-30h] BYREF

  v7[5] = __readfsqword(0x28u);
  //变量初始化
  puts("Let us play a game?");
  puts("you have six chances to input");
  puts("Come on!");
  //输出
  v6[0] = 0LL;
  v6[1] = 0LL;
  v6[2] = 0LL;
  v6[3] = 0LL;
  v6[4] = 0LL;
  for ( i = 0; i <= 5; ++i )
  {
    printf("%s", "input: ");
    a2 = (char **)((char *)v6 + 4 * i);
    __isoc99_scanf("%d", a2);
  }
  //捕获输入数据
  v7[0] = 0LL;
  v7[1] = 0LL;
  v7[2] = 0LL;
  v7[3] = 0LL;
  v7[4] = 0LL;
  for ( j = 0; j <= 2; ++j )
  {
    dword_601078 = v6[j];
    dword_60107C = HIDWORD(v6[j]);
    a2 = (char **)&unk_601060;
    sub_400686(&dword_601078, &unk_601060);
    LODWORD(v7[j]) = dword_601078;
    HIDWORD(v7[j]) = dword_60107C;
  }
  //加密函数
  if ( (unsigned int)sub_400770(v7, a2) != 1 )
  {
    puts("NO NO NO~ ");
    exit(0);
  }
  //答案校验
  puts("Congratulation!\n");
  puts("You seccess half\n");
  puts("Do not forget to change input to hex and combine~\n");
  puts("ByeBye");
  return 0LL;
}
```

追踪一个加密函数`sub_400686`：

```c
__int64 __fastcall sub_400686(unsigned int *a1, _DWORD *a2)
{
  __int64 result; // rax
  unsigned int v3; // [rsp+1Ch] [rbp-24h]
  unsigned int v4; // [rsp+20h] [rbp-20h]
  int v5; // [rsp+24h] [rbp-1Ch]
  unsigned int i; // [rsp+28h] [rbp-18h]

  v3 = *a1;
  v4 = a1[1];
  v5 = 0;
  for ( i = 0; i <= 0x3F; ++i ) //这里进行了循环异或计算
  {
    v5 += 1166789954;
    v3 += (v4 + v5 + 11) ^ ((v4 << 6) + *a2) ^ ((v4 >> 9) + a2[1]) ^ 0x20;
    v4 += (v3 + v5 + 20) ^ ((v3 << 6) + a2[2]) ^ ((v3 >> 9) + a2[3]) ^ 0x10;
  }
  *a1 = v3;
  result = v4;
  a1[1] = v4;
  return result;
}
```

~~*这里就能看到一丝TEA的感觉了*~~

再跟进一下`sub_400770`函数：

```c
__int64 __fastcall sub_400770(_DWORD *a1)
{
  __int64 result; // rax

  if ( a1[2] - a1[3] == 2225223423LL
    && a1[3] + a1[4] == 4201428739LL
    && a1[2] - a1[4] == 1121399208LL
    && *a1 == -548868226
    && a1[5] == -2064448480
    && a1[1] == 550153460 )
  {
    puts("good!");
    result = 1LL;
  }
  else
  {
    puts("Wrong!");
    result = 0LL;
  }
  return result;
}
```

`sub_400770`应该只是一个简单的校验函数。根据结构，就可以得出结论，应该是TEA加密算法的一种变种，有TEA加密的思想，但是加密逻辑和TEA加密不同，所以直接根据程序逻辑编写解密脚本：

```c
#include <stdio.h>
int main()
{
  unsigned int a1[] = {0, 0, 0, 0, 0, 0};
  a1[0] = 0xDF48EF7E;
  a1[5] = 0x84F30420;
  a1[1] = 0x20CAACF4;
  a1[3] = (0x42D731A8 - 0x84A236FF + 0xFA6CB703) / 2;
  a1[4] = 0xFA6CB703 - a1[3];
  a1[2] = a1[3] + 0x84A236FF;
  int i = 0, j = 0;
  int temp[2] = {0};
  int data[4] = {2, 2, 3, 4};
  for (i = 0; i < 5; i += 2)
  {
    unsigned int v3 = a1[i];
    unsigned int v4 = a1[i + 1];
    long long v5 = 0x458BCD42 * 64;
    for (j = 0; j < 64; j++)
    {
      v4 -= (v3 + v5 + 20) ^ ((v3 << 6) + 3) ^ ((v3 >> 9) + 4) ^ 0x10;
      v3 -= (v4 + v5 + 11) ^ ((v4 << 6) + 2) ^ ((v4 >> 9) + 2) ^ 0x20;
      v5 -= 0x458BCD42;
    }
    a1[i] = v3;
    a1[i + 1] = v4;
  }
  for (i = 0; i < 6; i++)
    printf("%c%c%c", *((char *)&a1[i] + 2), *((char *)&a1[i] + 1), *(char *)&a1[i]);
}
```

得到输出：

```text
flag{re_is_great!}
```

#### 2019红帽杯 xx

[\[2019红帽杯\]xx](https://buuoj.cn/challenges#%5B2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%5Dxx)

程序下载分析，无壳，64-bits，直接进IDA逆向，C++写的，看一下主函数：

```c++
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned __int64 v3;  // rbx
  __int64 v4;           // rax
  __int128 *v5;         // rax
  __int64 v6;           // r11
  __int128 *v7;         // r14
  int v8;               // edi
  __int128 *v9;         // rsi
  char v10;             // r10
  int v11;              // edx
  __int64 v12;          // r8
  unsigned __int64 v13; // rcx
  __int64 v14;          // rcx
  unsigned __int64 v15; // rax
  unsigned __int64 i;   // rax
  _BYTE *v17;           // rax
  size_t v18;           // rsi
  _BYTE *v19;           // rbx
  _BYTE *v20;           // r9
  int v21;              // er11
  char *v22;            // r8
  __int64 v23;          // rcx
  char v24;             // al
  __int64 v25;          // r9
  __int64 v26;          // rdx
  __int64 v27;          // rax
  size_t Size;          // [rsp+20h] [rbp-48h] BYREF
  __int128 v30;         // [rsp+28h] [rbp-40h] BYREF
  int v31;              // [rsp+38h] [rbp-30h]
  int v32;              // [rsp+3Ch] [rbp-2Ch]
  int Code[4];          // [rsp+40h] [rbp-28h] BYREF
  int v34;              // [rsp+50h] [rbp-18h]
  //变量初始化

  *(_OWORD *)Code = 0i64;
  v34 = 0;
  sub_1400018C0(std::cin, argv, Code);
  v3 = -1i64;
  v4 = -1i64;
  do
    ++v4;
  while (*((_BYTE *)Code + v4));
  if (v4 != 19)
  {
    sub_140001620(std::cout, "error\n");
    _exit((int)Code);
  }
  //根据输入数据的长度，初步校验
  v5 = (__int128 *)operator new(5ui64);
  v6 = *(_QWORD *)&::Code;
  v7 = v5;
  v8 = 0;
  v9 = v5;
  do
  {
    v10 = *((_BYTE *)v9 + (char *)Code - (char *)v5);
    v11 = 0;
    *(_BYTE *)v9 = v10;
    v12 = 0i64;
    v13 = -1i64;
    do
      ++v13;
    while (*(_BYTE *)(v6 + v13));
    if (v13)
    {
      do
      {
        if (v10 == *(_BYTE *)(v6 + v12))
          break;
        ++v11;
        ++v12;
      } while (v11 < v13);
    }
    v14 = -1i64;
    do
      ++v14;
    while (*(_BYTE *)(v6 + v14));
    if (v11 == v14)
      _exit(v6);
    v9 = (__int128 *)((char *)v9 + 1);
  } while ((char *)v9 - (char *)v5 < 4); 

  *((_BYTE *)v5 + 4) = 0;
  do
    ++v3;
  while (*((_BYTE *)Code + v3));
  v15 = 0i64;
  v30 = *v7;
  while (*((_BYTE *)&v30 + v15))
  {
    if (!*((_BYTE *)&v30 + v15 + 1))
    {
      ++v15;
      break;
    }
    if (!*((_BYTE *)&v30 + v15 + 2))
    {
      v15 += 2i64;
      break;
    }
    if (!*((_BYTE *)&v30 + v15 + 3))
    {
      v15 += 3i64;
      break;
    }
    v15 += 4i64;
    if (v15 >= 0x10)
      break;
  }
  for (i = v15 + 1; i < 0x10; ++i)
    *((_BYTE *)&v30 + i) = 0;
  v17 = sub_140001AB0((__int64)Code, v3, (unsigned __int8 *)&v30, &Size); //加密函数
  v18 = Size;
  v19 = v17;
  v20 = operator new(Size);
  v21 = 1;
  *v20 = v19[2];
  v22 = v20 + 1;
  v20[1] = *v19;
  v20[2] = v19[3];
  v20[3] = v19[1];
  v20[4] = v19[6];
  v20[5] = v19[4];
  v20[6] = v19[7];
  v20[7] = v19[5];
  v20[8] = v19[10];
  v20[9] = v19[8];
  v20[10] = v19[11];
  v20[11] = v19[9];
  v20[12] = v19[14];
  v20[13] = v19[12];
  v20[14] = v19[15];
  v20[15] = v19[13];
  v20[16] = v19[18];
  v20[17] = v19[16];
  v20[18] = v19[19];
  v20[19] = v19[17];
  v20[20] = v19[22];
  v20[21] = v19[20];
  v20[22] = v19[23];
  //变量按位变换
  for (v20[23] = v19[21]; v21 < v18; ++v22)
  {
    v23 = 0i64;
    if (v21 / 3 > 0)
    {
      v24 = *v22;
      do
      {
        v24 ^= v20[v23++];
        *v22 = v24;
      } while (v23 < v21 / 3);
    }
    ++v21;
  }
  *(_QWORD *)&v30 = 0xC0953A7C6B40BCCEui64;
  v25 = v20 - (_BYTE *)&v30;
  *((_QWORD *)&v30 + 1) = 0x3502F79120209BEFi64;
  v26 = 0i64;
  v31 = -939386845;
  v32 = -95004953;
  do
  {
    if (*((_BYTE *)&v30 + v26) != *((_BYTE *)&v30 + v26 + v25))
      _exit(v8 * v8);
    ++v8;
    ++v26;
  } while (v26 < 24);
  v27 = sub_140001620(std::cout, "You win!");
  std::ostream::operator<<(v27, sub_1400017F0);
  return 0;
}
```

可以看出是经过`sub_140001AB0`函数加密之后，再处理数据之后，校验结果。

1. 先判断输入的字符串是否都在程序实现存储的数据Code中
2. 然后取前四个字符作为xxtea的密钥，（不满位数右端补零）
3. 然后对输入的字符串进行加密
4. 之后对加密的字符串打乱顺序
5. 之后异或操作
6. 再与存储的数据进行比对

看一下`sub_140001AB0`函数：

```c++
_BYTE *__fastcall sub_140001AB0(__int64 a1, unsigned __int64 a2, unsigned __int8 *a3, unsigned __int64 *a4)
{
  unsigned __int64 *v4; // r13
  __int64 v8; // rdi
  size_t v9; // rcx
  _DWORD *v10; // rax
  _DWORD *v11; // r15
  __int64 v12; // r14
  unsigned __int64 v13; // rdi
  unsigned __int64 i; // r9
  int v15; // edx
  _DWORD *v16; // r8
  char v17; // cl
  _DWORD *v18; // r12
  int v19; // ecx
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int v23; // ecx
  int v24; // eax
  int v25; // ecx
  int v26; // eax
  unsigned int v27; // ebp
  __int64 v28; // rcx
  unsigned int v29; // er10
  unsigned int v30; // eax
  __int64 v31; // r9
  unsigned int *v32; // rbx
  __int64 v33; // r11
  _DWORD *v34; // rax
  __int64 v35; // rsi
  __int64 v36; // r14
  char v37; // r13
  unsigned int v38; // er8
  __int64 v39; // rcx
  unsigned __int64 v40; // rbx
  size_t v41; // rcx
  _BYTE *v42; // rax
  _BYTE *v43; // rsi
  _BYTE *result; // rax
  char v45; // [rsp+20h] [rbp-58h]
  __int64 v46; // [rsp+28h] [rbp-50h]
  __int64 v47; // [rsp+30h] [rbp-48h]
  unsigned int v48; // [rsp+88h] [rbp+10h]
  unsigned __int64 *v49; // [rsp+98h] [rbp+20h]

  v49 = a4;
  v4 = a4;
  if ( !a2 )
    return 0i64;
  v8 = a2 >> 2;
  if ( (a2 & 3) != 0 )
    v8 = (a2 >> 2) + 1;
  v9 = v8 + 1;
  if ( v8 == -1 )
    v9 = -1i64;
  v10 = calloc(v9, 4ui64);
  v11 = v10;
  if ( !v10 )
    return 0i64;
  v12 = v8 + 1;
  v10[v8] = a2;
  v13 = 0i64;
  v47 = v12;
  for ( i = 0i64; i < a2; *v16 |= v15 << (8 * v17) )
  {
    v15 = *(unsigned __int8 *)(i + a1);
    v16 = &v10[i >> 2];
    v17 = i++ & 3;
  }
  v18 = calloc(4ui64, 4ui64);
  if ( v18 )
  {
    v19 = a3[7] << 8;
    v20 = a3[6];
    *v18 |= *a3 | ((a3[1] | (*((unsigned __int16 *)a3 + 1) << 8)) << 8);
    v21 = a3[4] | ((a3[5] | ((v20 | v19) << 8)) << 8);
    v22 = a3[10];
    v18[1] |= v21;
    v23 = a3[8] | ((a3[9] | ((v22 | (a3[11] << 8)) << 8)) << 8);
    v24 = a3[14];
    v18[2] |= v23;
    v25 = a3[13] | ((v24 | (a3[15] << 8)) << 8);
    v26 = a3[12];
    v27 = 0;
    v18[3] |= v26 | (v25 << 8);
    v28 = (unsigned int)(v12 - 1);
    v29 = v11[v28];
    v30 = 0x34 / (unsigned int)v12 + 6;
    v31 = v28;
    v45 = v12 - 1;
    v46 = v28;
    if ( (_DWORD)v12 != 1 && 0x34 / (unsigned int)v12 != -6 )
    {
      do
      {
        v32 = v11 + 1;
        v27 -= 1640531527;
        v48 = v30 - 1;
        v33 = 0i64;
        v34 = v11;
        v35 = (v27 >> 2) & 3;
        v36 = v31;
        v37 = v28;
        do
        {
          v38 = *v32++;
          ++v34;
          v39 = v35 ^ v33++ & 3;
          *(v34 - 1) += ((v27 ^ v38) + (v29 ^ v18[v39])) ^ (((16 * v29) ^ (v38 >> 3)) + ((v29 >> 5) ^ (4 * v38)));
          v29 = *(v34 - 1);
          --v36;
        }
        while ( v36 );
        v31 = v46;
        LOBYTE(v28) = v45;
        v30 = v48;
        v11[v46] += ((v27 ^ *v11) + (v29 ^ v18[v35 ^ v37 & 3])) ^ (((4 * *v11) ^ (v29 >> 5)) + ((*v11 >> 3) ^ (16 * v29)));
        v29 = v11[v46];
      }
      while ( v48 );
      v12 = v47;
      v4 = v49;
    }
    v40 = 4 * v12;
    v41 = 4 * v12 + 1;
    if ( 4 * v12 == -1 )
      v41 = -1i64;
    v42 = malloc(v41);
    v43 = v42;
    if ( v40 )
    {
      do
      {
        v42[v13] = v11[v13 >> 2] >> (8 * (v13 & 3));
        ++v13;
      }
      while ( v13 < v40 );
    }
    v42[4 * v12] = 0;
    *v4 = v40;
    free(v11);
    free(v18);
    result = v43;
  }
  else
  {
    free(v11);
    result = 0i64;
  }
  return result;
}
```

在其中发现了关键的`a key schedule constant`：

```text
1640531527
```

并且其中的计算逻辑符合TEA加密规则：

```c++
do
{
  v32 = v11 + 1;
  v27 -= 1640531527;
  v48 = v30 - 1;
  v33 = 0i64;
  v34 = v11;
  v35 = (v27 >> 2) & 3;
  v36 = v31;
  v37 = v28;
  do
  {
    v38 = *v32++;
    ++v34;
    v39 = v35 ^ v33++ & 3;
    *(v34 - 1) += ((v27 ^ v38) + (v29 ^ v18[v39])) ^ (((16 * v29) ^ (v38 >> 3)) + ((v29 >> 5) ^ (4 * v38)));
    v29 = *(v34 - 1);
    --v36;
  } while (v36);
  v31 = v46;
  LOBYTE(v28) = v45;
  v30 = v48;
  v11[v46] += ((v27 ^ *v11) + (v29 ^ v18[v35 ^ v37 & 3])) ^ (((4 * *v11) ^ (v29 >> 5)) + ((*v11 >> 3) ^ (16 * v29)));
  v29 = v11[v46];
}
```

所以可以判断这个是xxTEA加密。编写脚本，先用Python处理数据顺序：

```python
v18 = [0xce, 0xbc, 0x40, 0x6b, 0x7c, 0x3a, 0x95, 0xc0, 0xef, 0x9b, 0x20, 0x20,
       0x91, 0xf7, 0x02, 0x35, 0x23, 0x18, 0x02, 0xc8, 0xe7, 0x56, 0x56, 0xfa]
v19 = []
for i in range(24):
    v19.append(0)
for i in range(len(v18)-1, -1, -1):
    if i >= 3:
        for j in range(i//3):
            v18[i] ^= v18[j]
print(v18)
v19[2] = v18[0]
v19[0] = v18[1]
v19[3] = v18[2]
v19[1] = v18[3]
v19[6] = v18[4]
v19[4] = v18[5]
v19[7] = v18[6]
v19[5] = v18[7]
v19[10] = v18[8]
v19[8] = v18[9]
v19[11] = v18[10]
v19[9] = v18[11]
v19[14] = v18[12]
v19[12] = v18[13]
v19[15] = v18[14]
v19[13] = v18[15]
v19[18] = v18[16]
v19[16] = v18[17]
v19[19] = v18[18]
v19[17] = v18[19]
v19[22] = v18[20]
v19[20] = v18[21]
v19[23] = v18[22]
v19[21] = v18[23]
print(v19)
for i in range(len(v19)):
    v19[i] = hex(v19[i])
print(v19)
```

得到输出：

```text
'0xbc', '0xa5', '0xce', '0x40', '0xf4', '0xb2', '0xb2', '0xe7', '0xa9', '0x12', '0x9d', '0x12', '0xae', '0x10', '0xc8', '0x5b', '0x3d', '0xd7', '0x6', '0x1d', '0xdc', '0x70', '0xf8', '0xdc'
```

然后使用C处理xxTEA解密：

```c
#include <stdio.h>
#include <stdint.h>
#define DELTA 0x9e3779b9
#define MX (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((sum^y) + (key[(p&3)^e] ^ z)))
void btea(uint32_t *v, int n, uint32_t const key[4])
{
    uint32_t y, z, sum;
    unsigned p, rounds, e;
    if (n > 1)            /* Coding Part */
    {
        rounds = 6 + 52 / n;
        sum = 0;
        z = v[n - 1];
        do
        {
            sum += DELTA;
            e = (sum >> 2) & 3;
            for (p = 0; p<n - 1; p++)
            {
                y = v[p + 1];
                z = v[p] += MX;
            }
            y = v[0];
            z = v[n - 1] += MX;
        }
        while (--rounds);
    }
    else if (n < -1)      /* Decoding Part */
    {
        n = -n;
        rounds = 6 + 52 / n;
        sum = rounds*DELTA;
        y = v[0];
        do
        {
            e = (sum >> 2) & 3;
            for (p = n - 1; p>0; p--)
            {
                z = v[p - 1];
                y = v[p] -= MX;
            }
            z = v[n - 1];
            y = v[0] -= MX;
            sum -= DELTA;
        }
        while (--rounds);
    }
}
int main()
{
    uint32_t v[6] = { (unsigned int)0x40cea5bc, (unsigned int)0xe7b2b2f4,(unsigned int)0x129d12a9,(unsigned int)0x5bc810ae,(unsigned int)0x1d06d73d,(unsigned int)0xdcf870dc };
    uint32_t const k[4] = { (unsigned int)0x67616c66, (unsigned int)0x0, (unsigned int)0X0, (unsigned int)0x0 };
    int n = 6; //n的绝对值表示v的长度，取正表示加密，取负表示解密
    // v为要加密的数据是两个32位无符号整数
    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位
    btea(v, -n, k);
    printf("加密后的数据：%x %x %x %x %x\n", v[0], v[1],v[2],v[3],v[4],v[5]);
}
```

得到输出：

```text
加密后的数据：67616c66 5858437b 646e615f 742b2b5f 7d6165
```

然后再用C解密数据：

```c
#include <stdio.h>
int main()
{
    char string[] = "67616c665858437b646e615f742b2b5f7d6165";
    int i = 1,j=0;
    for (;i<6;i++)
    {
        for (j = 0; j < 8; j += 2)
        {
            if (j == 0 && i == 5)
                continue;
            printf("%c%c", string[i * 8 - j - 2], string[i * 8 - j - 1]);
        }
    }

}
```

得到输出：

```text
666c61677b4358585f616e645f2b2b7465617d
```

最后再用Python转换HEX数据为字符串：

```python
import binascii
hex_str="666c61677b4358585f616e645f2b2b7465617d"
str_bin = binascii.unhexlify(hex_str.encode('utf-8'))
print(str_bin.decode('utf-8'))
```

得到输出：

```text
flag{CXX_and_++tea}
```

## RC4

> RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。RC4于1987年提出，和DES算法一样，是一种对称加密算法，也就是说使用的密钥为单钥（或称为私钥）。但不同于DES的是，RC4不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。
> RC4算法的特点是算法简单，运行速度快，而且密钥长度是可变的，可变范围为1-256字节(8-2048比特)，在如今技术支持的前提下，当密钥长度为128比特时，用暴力法搜索密钥已经不太可行，所以可以预见RC4的密钥范围任然可以在今后相当长的时间里抵御暴力搜索密钥的攻击。实际上，如今也没有找到对于128bit密钥长度的RC4加密算法的有效攻击方法。

### 核心要素

1. 密钥流：RC4算法的关键是根据明文和密钥生成相应的密钥流，密钥流的长度和明文的长度是对应的，也就是说明文的长度是500字节，那么密钥流也是500字节。当然，加密生成的密文也是500字节，因为密文第i字节=明文第i字节^密钥流第i字节；

2. 状态向量S：长度为256，S\[0\],S\[1\].....S\[255\]。每个单元都是一个字节，算法运行的任何时候，S都包括0-255的8比特数的排列组合，只不过值的位置发生了变换；

3. 临时向量T：长度也为256，每个单元也是一个字节。如果密钥的长度是256字节，就直接把密钥的值赋给T，否则，轮转地将密钥的每个字节赋给T；

4. 密钥K：长度为1-256字节，注意密钥的长度keylen与明文长度、密钥流的长度没有必然关系，通常密钥的长度趋为16字节（128比特）。

### 基本流程

RC4 主要包含三个流程

- 初始化 S 和 T 数组。
- 初始化置换 S。
- 生成密钥流。

#### 初始化 S 和 T 数组

初始化 S 和 T 的代码如下

```c
for i = 0 to 255 do
    S[i] = i
    T[i] = K[i mod keylen])
```

#### 初始化置换 S

```c
j = 0
for i = 0 to 255 do 
    j = (j + S[i] + T[i]) (mod 256) 
    swap (S[i], S[j])
```

#### 生成流密钥

```c
i = j = 0 
for each message byte b
    i = (i + 1) (mod 256)
    j = (j + S[i]) (mod 256)
    swap(S[i], S[j])
    t = (S[i] + S[j]) (mod 256) 
    print S[t]
```

我们一般称前两部分为 KSA ，最后一部分是 PRGA。

### 示例代码

在C下的实现：

```c
void rc4_init(unsigned char *s, unsigned char *key, unsigned long Len) //初始化函数
{
    int i =0, j = 0;
    char k[256] = {0};
    unsigned char tmp = 0;
    for (i=0;i<256;i++) {
        s[i] = i;
        k[i] = key[i%Len];
    }
    for (i=0; i<256; i++) {
        j=(j+s[i]+k[i])%256;
        tmp = s[i];
        s[i] = s[j]; //交换s[i]和s[j]
        s[j] = tmp;
    }
 }
void rc4_crypt(unsigned char *s, unsigned char *Data, unsigned long Len) //加解密
{
    int i = 0, j = 0, t = 0;
    unsigned long k = 0;
    unsigned char tmp;
    for(k=0;k<Len;k++) {
        i=(i+1)%256;
        j=(j+s[i])%256;
        tmp = s[i];
        s[i] = s[j]; //交换s[x]和s[y]
        s[j] = tmp;
        t=(s[i]+s[j])%256;
        Data[k] ^= s[t];
     }
} 
```

这是在Python下的实现（也就意味着可以脚本一把梭）：

```python
import hashlib
import base64

def Rc4_init(S, K):  # S盒初始化置换,K为密钥
    j = 0
    K = hashlib.md5(bytes(str(K).encode())).hexdigest()
    k = []  # 临时数组
    for i in range(256):
        S.append(i)
        k.append(K[i % len(K)])
    for i in range(256):
        j = (j + S[i] + ord(k[i])) % 256
        S[i], S[j] = S[j], S[i]  # 交换S[i],S[j]

def rc4_Encrypt(S, D): #加密函数
    i = j = 0
    result = ''
    for a in D:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        t = (S[i] + S[j]) % 256
        k = chr(ord(a) ^ S[(S[i] + S[j]) % 256])
        result += k
    result = base64.b64encode(bytes(result.encode()))
    return result


def rc4_Decrypt(S, D): #解密函数
    i = j = 0
    D = base64.b64decode(D)
    result = ''
    for a in D:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        t = (S[i] + S[j]) % 256
        k = chr(a ^ S[(S[i] + S[j]) % 256])
        result += k
    return result

if __name__=="__main__":
    key = 'NISA'
    d = 'testtest'
    print("key :"+key)
    print("m: "+d)
    s = []
    Rc4_init(s, key) #临时向量T
    c = rc4_Encrypt(s, d)
    print("Encrypt: "+str(bytes(c).decode()))
    s = []
    Rc4_init(s, key)
    z = rc4_Decrypt(s, c)
    print("Decrypt: "+z)
```

### 例题

#### GUET-CTF2019 encrypt

[[GUET-CTF2019]encrypt](https://buuoj.cn/challenges#%5BGUET-CTF2019%5Dencrypt)

附件下载分析，ELF文件，无壳，64-bits，IDA逆向，看一下主函数（简单备注+函数改名）：

```c
__int64 __fastcall main(int a1, char **a2, char **a3)
{
  unsigned int v3; // eax
  int v4; // eax
  int v6; // [rsp+4h] [rbp-93Ch] BYREF
  int i; // [rsp+8h] [rbp-938h]
  int v8; // [rsp+Ch] [rbp-934h]
  char v9[1040]; // [rsp+10h] [rbp-930h] BYREF
  char v10[16]; // [rsp+420h] [rbp-520h] BYREF
  char s[256]; // [rsp+430h] [rbp-510h] BYREF
  char v12[1032]; // [rsp+530h] [rbp-410h] BYREF
  unsigned __int64 v13; // [rsp+938h] [rbp-8h]
  //变量初始化
  v13 = __readfsqword(0x28u);
  v10[0] = 16;
  v10[1] = 32;
  v10[2] = 48;
  v10[3] = 48;
  v10[4] = 32;
  v10[5] = 32;
  v10[6] = 16;
  v10[7] = 64;
  memset(s, 0, sizeof(s));
  v8 = strlen(s);
  memset(v12, 0, 0x400uLL);
  //第二次变量初始化（带初始数据）
  printf("please input your flag:");
  scanf("%s", s);
  //输入输出
  memset(v9, 0, 0x408uLL);
  RC4_S(v9, v10, 8LL); // 初始化S盒以及伪随机打乱
  v3 = strlen(s);
  RC4(v9, s, v3); // 查盒获取key,与明文异或
  v4 = strlen(s);
  sub_4008FA((__int64)s, v4, v12, &v6); // 三字节转换成四字节
  for ( i = 0; i <= 50; ++i ) //答案校验
  {
    if ( v12[i] != byte_602080[i] ) 
    {
      puts("Wrong");
      return 0LL;
    }
  }
  puts("Good");
  return 0LL;
}
```

RC4_S：

```c
void __fastcall RC4_S(_DWORD *a1, __int64 a2, int a3)
//*a1-->v9   a2-->v10   a3=8LL
{
  int i; // [rsp+1Ch] [rbp-18h]
  int j; // [rsp+1Ch] [rbp-18h]
  int v5; // [rsp+20h] [rbp-14h]
  int v6; // [rsp+24h] [rbp-10h]
  int v7; // [rsp+28h] [rbp-Ch]
  _DWORD *v8; // [rsp+2Ch] [rbp-8h]

  *a1 = 0;
  a1[1] = 0;
  v8 = a1 + 2;
  for ( i = 0; i <= 255; ++i )
    v8[i] = i;
  v6 = 0;
  LOBYTE(v5) = 0;
  for ( j = 0; j <= 255; ++j )
  {
    v7 = v8[j];
    v5 = (unsigned __int8)(v5 + v7 + *(_BYTE *)(v6 + a2));
    v8[j] = v8[v5];
    v8[v5] = v7;
    if ( ++v6 >= a3 )
      v6 = 0;
  }
}
```

RC4：

```c
void __fastcall RC4(_DWORD *a1, __int64 a2, int a3)
{
  int i; // [rsp+18h] [rbp-1Ch]
  int v4; // [rsp+1Ch] [rbp-18h]
  int v5; // [rsp+20h] [rbp-14h]
  int v6; // [rsp+24h] [rbp-10h]
  int v7; // [rsp+28h] [rbp-Ch]
  _DWORD *v8; // [rsp+2Ch] [rbp-8h]

  v4 = *a1;
  v5 = a1[1];
  v8 = a1 + 2;
  for ( i = 0; i < a3; ++i )
  {
    v4 = (unsigned __int8)(v4 + 1);
    v6 = v8[v4];
    v5 = (unsigned __int8)(v5 + v6);
    v7 = v8[v5];
    v8[v4] = v7;
    v8[v5] = v6;
    *(_BYTE *)(i + a2) ^= LOBYTE(v8[(unsigned __int8)(v6 + v7)]);
  }
  *a1 = v4;
  a1[1] = v5;
}
```

sub_4008FA：

```c
_DWORD *__fastcall sub_4008FA(__int64 a1, int a2, const char *a3, _DWORD *a4)
{
  int v4; // eax
  int v5; // eax
  unsigned __int8 v6; // al
  int v7; // eax
  unsigned __int8 v8; // al
  int v9; // eax
  int v10; // edx
  _DWORD *result; // rax
  char v13; // [rsp+2Dh] [rbp-13h]
  unsigned __int8 v14; // [rsp+2Eh] [rbp-12h]
  unsigned __int8 v15; // [rsp+2Fh] [rbp-11h]
  int v16; // [rsp+30h] [rbp-10h]
  int v17; // [rsp+34h] [rbp-Ch]

  v16 = 0;
  v17 = 0;
  while ( v17 < a2 )
  {
    v4 = v17++;
    v13 = *(_BYTE *)(v4 + a1);
    if ( v17 >= a2 )
    {
      v6 = 0;
    }
    else
    {
      v5 = v17++;
      v6 = *(_BYTE *)(v5 + a1);
    }
    v14 = v6;
    if ( v17 >= a2 )
    {
      v8 = 0;
    }
    else
    {
      v7 = v17++;
      v8 = *(_BYTE *)(v7 + a1);
    }
    v15 = v8;
    a3[v16] = ((v13 >> 2) & 0x3F) + 61;
    a3[v16 + 1] = ((((int)v14 >> 4) | (16 * v13)) & 0x3F) + 61;
    a3[v16 + 2] = ((((int)v8 >> 6) | (4 * v14)) & 0x3F) + 61;
    v9 = v16 + 3;
    v16 += 4;
    a3[v9] = (v15 & 0x3F) + 61;
  }
  if ( a2 % 3 == 1 )
  {
    a3[--v16] = 61;
  }
  else if ( a2 % 3 != 2 )
  {
    goto LABEL_15;
  }
  a3[v16 - 1] = 61;
LABEL_15:
  v10 = strlen(a3);
  result = a4;
  *a4 = v10;
  return result;
}
```

`sub_4008FA`类似于Base64加密中的三字节拆分成四字节的运算。

这个程序的加密逻辑符合RC4加密，但是由于\`flag\`\`的数据并不属于Printable范畴，于是优先考虑使用C脚本来解密：

```c
#include<stdio.h>
void RC4_Decrypt(unsigned char *flag,int Len,int *T)
{
    unsigned char S[256];
    int i,j,m,key,tmp1,tmp2;
    for(i=0;i<256;i++)    //初始化S盒
        S[i]=i;
    j=0;
    for(i=0;i<256;i++)
    {
        j=(j+S[i]+T[i%8])%256;
        tmp1=S[i];tmp2=S[j];    //交换位置
        S[i]=tmp2;S[j]=tmp1;   
    }
    j=0;    
    for(m=0;m<Len;m++)     
    {
        i=(i+1)%256;
        j=(j+S[i])%256;
        tmp1=S[i];tmp2=S[j];S[i]=tmp2;S[j]=tmp1;  //交换位置
        key=S[(S[i]+S[j])%256];   //获取密钥
        flag[m]^=key;
    }
}
int main()
{   
    unsigned char cmp[52]={0x5A, 0x60, 0x54, 0x7A, 0x7A, 0x54, 0x72, 0x44, 0x7C, 0x66, 0x51, 0x50, 0x5B, 0x5F, 0x56, 0x56, 0x4C, 0x7C, 0x79, 0x6E, 0x65, 0x55, 0x52, 0x79, 0x55, 0x6D, 0x46, 0x6B, 0x6C, 0x56, 0x4A, 0x67, 0x4C, 0x61, 0x73, 0x4A, 0x72, 0x6F, 0x5A, 0x70, 0x48, 0x52, 0x78, 0x49, 0x55, 0x6C, 0x48, 0x5C, 0x76, 0x5A, 0x45, 0x3D};
    //cmp为比较内容,总长度为52
    int Len = 52/4*3;   //确定flag长度
    unsigned char flag[Len];   //unsigned char表明范围为0x0~0xFF,当高于0xFF时,会自动舍弃多余部分
    int T[] = {16,32,48,48,32,32,16,64};    //用于打乱S盒内部顺序

    int i,j;
    for(i = 0;i < 52; i++)
        cmp[i] -= 61;
    for(i = 0,j = 0;i < 52;i += 4,j += 3)   //四字节转换成三字节
    {
        flag[j] = cmp[i]<<2 | cmp[i+1]>>4;
        flag[j+1] = cmp[i+1]<<4 | cmp[i+2]>>2;
        flag[j+2] = cmp[i+2]<<6 | cmp[i+3];
    }
    RC4_Decrypt(flag,Len,T);   //RC4解密
    for(i=0;i<Len;i++)
        printf("%c",flag[i]);
}
```

得到输出：

```text
flag{e10adc3949ba59abbe56e057f20f883e}
```

## SHA-1

> SHA-1（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，美国国家安全局设计，并由美国国家标准技术研究所（NIST）发布为联邦数据处理标准（FIPS）。SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。

这个算法本质上与MD5类似，但是比MD5的抗爆破更强。

### 示例代码

```c
/*
SHA1 算法产出的是160位的摘要 即 32 * 5长度
有五个字(这里为32位)
*/

#include <cstdio>
#include <cstring>
#include <Windows.h>
#pragma warning(disable : 4309)
#pragma warning(disable : 4996)
#define EACH_HADLE_LEN 64 //每次处理64字节

char cipher[40] = "\0"; //32 * 5 32位表示 8个十六进制

typedef struct sha1_context
{
  DWORD length;
  DWORD hashRes[5];
  unsigned char block[64]; //64字节的块
} sha1_context;

DWORD RoLeft(DWORD value, int index)
{
  return (value << index) ^ (value >> (32 - index));
}

void SHA1Init(sha1_context *sha1)
{
  sha1->length = 0;
  sha1->hashRes[0] = 0x67452301; //初始化H[0] H[1] H[2] H[3] H[4]
  sha1->hashRes[1] = 0xefcdab89;
  sha1->hashRes[2] = 0x98badcfe;
  sha1->hashRes[3] = 0x10325476;
  sha1->hashRes[4] = 0xc3d2e1f0;
}

void ProcessEachBlock(sha1_context *sha1)
{
  DWORD a, b, c, d, e; //五个缓冲区
  DWORD W[80];
  DWORD temp;
  int i, j;

  for (i = 0, j = 0; j < 16; i += 4, j++)
  {                                                                                                                //初始化W[0] ~ W[15]
    W[j] = (sha1->block[i] << 24) | (sha1->block[i + 1] << 16) | (sha1->block[i + 2] << 8) | (sha1->block[i + 3]); //产生一个32位的字
  }

  for (i = 16; i < 80; i++)
  { //产生W[16] ~ W[79]
    temp = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
    W[i] = RoLeft(temp, 1);
  }

  //初始化a b c d e
  a = sha1->hashRes[0];
  b = sha1->hashRes[1];
  c = sha1->hashRes[2];
  d = sha1->hashRes[3];
  e = sha1->hashRes[4];

  for (i = 0; i < 20; i++)
  {                                                                    //前20
    temp = RoLeft(a, 5) + (((c ^ d) & b) ^ d) + e + W[i] + 0x5A827999; //产生新值
    //循环赋值
    e = d;
    d = c;
    c = RoLeft(b, 30);
    b = a;
    a = temp;
  }

  for (i = 20; i < 40; i++)
  {
    temp = RoLeft(a, 5) + (b ^ c ^ d) + e + W[i] + 0x6ED9EBA1; //产生新值
    //循环赋值
    e = d;
    d = c;
    c = RoLeft(b, 30);
    b = a;
    a = temp;
  }

  for (i = 40; i < 60; i++)
  {
    temp = RoLeft(a, 5) + ((b & c) | (b & d) | (c & d)) + e + W[i] + 0x8F1BBCDC; //产生新值
    //循环赋值
    e = d;
    d = c;
    c = RoLeft(b, 30);
    b = a;
    a = temp;
  }

  for (i = 60; i < 80; i++)
  {
    temp = RoLeft(a, 5) + (b ^ c ^ d) + e + W[i] + 0xCA62C1D6; //产生新值
    //循环赋值
    e = d;
    d = c;
    c = RoLeft(b, 30);
    b = a;
    a = temp;
  }

  //获得新的hash值
  sha1->hashRes[0] += a;
  sha1->hashRes[1] += b;
  sha1->hashRes[2] += c;
  sha1->hashRes[3] += d;
  sha1->hashRes[4] += e;
}

//每次处理512bit 即是处理64字节
void SHA1Update(sha1_context *sha1, char *data)
{
  sha1->length += strlen(data);

  while (sha1->length >= EACH_HADLE_LEN)
  {
    memcpy(sha1->block, data, EACH_HADLE_LEN); //获得M[i]
    ProcessEachBlock(sha1);

    data += EACH_HADLE_LEN;         //移动到下一个块
    sha1->length -= EACH_HADLE_LEN; //减去相应的长度
  }

  //对最后进行一轮进行一些补位操作 这里先清空 这样就可以不需要填0操作
  memset(sha1->block, 0, sizeof(char) * EACH_HADLE_LEN);
  memcpy(sha1->block, data, sha1->length);                         //剩余的数据进行填充
  sha1->block[sha1->length] = 0x80;                                //最高位填充1
  unsigned long long bitLen = sha1->length << 3;                   //获得bit长度 从而填充最后64bit位
  memcpy(&(sha1->block[56]), &bitLen, sizeof(unsigned long long)); //直接copy内存的话 因为内存是小端序的 所以非常方便 学到了！
  for (int i = 0; i < 4; i++)
  { //这里注意要颠倒
    DWORD temp = sha1->block[56 + i];
    sha1->block[56 + i] = sha1->block[63 - i];
    sha1->block[63 - i] = temp;
  }
  ProcessEachBlock(sha1); //最后一次运算
}

void PrintSHA1(sha1_context *sha1)
{
  int i;
  char hashValue[9];

  printf("\nresult of the SHA - 1 is : ");

  for (i = 0; i < 5; i++)
  {
    ZeroMemory(hashValue, 9 * sizeof(char));
    sprintf(hashValue, "%08x", sha1->hashRes[i]); //得到8个十六进制
    printf("%s", hashValue);
  }
}

void SHA1Encrypt(char *data) //传入要加密的数据
{
  sha1_context sha1 = {0};

  SHA1Init(&sha1);         //初始化长度
  SHA1Update(&sha1, data); //产生40字节的hash值
  PrintSHA1(&sha1);
}

int main()
{
  char data[] = "message digest";
  printf("len of plainText : %x\n", strlen(data) << 3);
  SHA1Encrypt(data);
}
```

另外，这是基于Python的实现：

```python
import hashlib
res=""
encrypts = hashlib.sha1(res.encode('utf-8')).hexdigest() # decode是解密，可以直接更改模式
print(encrypts)
print(encrypts)
```

### 例题

```python
pass
```

## MD5

> MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321 标准中被加以规范。1996年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞（collision），因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。

~~***彩虹表万岁***~~

### 示例代码

关于MD5在C上的实现，请看这篇文章：[MD5的C源码](https://blog.csdn.net/flydream0/article/details/7049322)（代码太长了，人生苦短，我用Python）（还是要能从C代码看出来MD5的逻辑）

在Python上的实现：

```python
import hashlib
s="123"
m = hashlib.md5(s.encode()).hexdigest()
print(m)
```

### 例题

```python
pass
```

## AES

> 密码学中的高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。
> 
> 这个标准用来替代原先的DES（Data Encryption Standard），已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院 （NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一 \[1\] 。
> 该算法为比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，以Rijdael之名命之，投稿高级加密标准的甄选流程。（Rijdael的发音近于 "Rhine doll"。）

有关C的实现，请参见[AES算法描述及C语言实现](https://blog.csdn.net/shaosunrise/article/details/80219950)

### 例题

```python
pass
```

## DES

> DES全称为Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。需要注意的是，在某些文献中，作为算法的DES称为数据加密算法（Data Encryption Algorithm,DEA），已与作为标准的DES区分开来。
> 
> DES算法的入口参数有三个：Key、Data、Mode。其中Key为7个字节共56位，是DES算法的工作密钥；Data为8个字节64位，是要被加密或被解密的数据；Mode为DES的工作方式,有两种:加密或解密。
> 
> DES设计中使用了分组密码设计的两个原则：混淆（confusion）和扩散(diffusion)，其目的是抗击敌手对密码系统的统计分析。混淆是使密文的统计特性与密钥的取值之间的关系尽可能复杂化，以使密钥和明文以及密文之间的依赖性对密码分析者来说是无法利用的。扩散的作用就是将每一位明文的影响尽可能迅速地作用到较多的输出密文位中，以便在大量的密文中消除明文的统计结构，并且使每一位密钥的影响尽可能迅速地扩展到较多的密文位中，以防对密钥进行逐段破译。

### 示例代码

有关C的实现，参见[des加密算法（c语言版）](https://blog.csdn.net/qq_34838643/article/details/80007992)

### 例题

```python
pass
```

## 后记

分析加密函数是重要的，但是不是最重要的。对程序逻辑的整体把握和对输入的数据流的处理流程的追踪，才是最为核心的部分。举个例子：

### 2019红帽杯 easyRE

[[2019红帽杯]easyRE](https://buuoj.cn/challenges#%5B2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%5DeasyRE)

直接找字符串列表，定位到涉及Base64加密的函数：

```c
__int64 sub_4009C6()
{
  __int64 result; // rax
  int i; // [rsp+Ch] [rbp-114h]
  __int64 v2; // [rsp+10h] [rbp-110h]
  __int64 v3; // [rsp+18h] [rbp-108h]
  __int64 v4; // [rsp+20h] [rbp-100h]
  __int64 v5; // [rsp+28h] [rbp-F8h]
  __int64 v6; // [rsp+30h] [rbp-F0h]
  __int64 v7; // [rsp+38h] [rbp-E8h]
  __int64 v8; // [rsp+40h] [rbp-E0h]
  __int64 v9; // [rsp+48h] [rbp-D8h]
  __int64 v10; // [rsp+50h] [rbp-D0h]
  __int64 v11; // [rsp+58h] [rbp-C8h]
  char v12[13]; // [rsp+60h] [rbp-C0h] BYREF
  char v13[4]; // [rsp+6Dh] [rbp-B3h] BYREF
  char v14[19]; // [rsp+71h] [rbp-AFh] BYREF
  char v15[32]; // [rsp+90h] [rbp-90h] BYREF
  int v16; // [rsp+B0h] [rbp-70h]
  char v17; // [rsp+B4h] [rbp-6Ch]
  char v18[72]; // [rsp+C0h] [rbp-60h] BYREF
  unsigned __int64 v19; // [rsp+108h] [rbp-18h]

  v19 = __readfsqword(0x28u);
  qmemcpy(v12, "Iodl>Qnb(ocy", 12);
  v12[12] = 127;
  qmemcpy(v13, "y.i", 3);
  v13[3] = 127;
  qmemcpy(v14, "d`3w}wek9{iy=~yL@EC", sizeof(v14));
  memset(v15, 0, sizeof(v15));
  v16 = 0;
  v17 = 0;
  sub_4406E0(0LL, v15, 37LL);
  v17 = 0;
  if ( sub_424BA0(v15) == 36 )
  {
    for ( i = 0; i < (unsigned __int64)sub_424BA0(v15); ++i )
    {
      if ( (unsigned __int8)(v15[i] ^ i) != v12[i] )
      {
        result = 4294967294LL;
        goto LABEL_13;
      }
    }
    sub_410CC0("continue!");
    memset(v18, 0, 0x40uLL);
    v18[64] = 0;
    sub_4406E0(0LL, v18, 64LL);
    v18[39] = 0;
    if ( sub_424BA0(v18) == 39 )
    {
      v2 = sub_400E44(v18);
      v3 = sub_400E44(v2);
      v4 = sub_400E44(v3);
      v5 = sub_400E44(v4);
      v6 = sub_400E44(v5);
      v7 = sub_400E44(v6);
      v8 = sub_400E44(v7);
      v9 = sub_400E44(v8);
      v10 = sub_400E44(v9);
      v11 = sub_400E44(v10);
      if ( !(unsigned int)sub_400360(v11, off_6CC090) )
      {
        sub_410CC0("You found me!!!");
        sub_410CC0("bye bye~");
      }
      result = 0LL;
    }
    else
    {
      result = 4294967293LL;
    }
  }
  else
  {
    result = 0xFFFFFFFFLL;
  }
LABEL_13:
  if ( __readfsqword(0x28u) != v19 )
    sub_444020();
  return result;
}
```

是十次base64加密，将明文进行十次base64解密，得到https://bbs.pediy.com/thread-254172.htm，点进去就会发现你被坑了......

其实核心在于`sub_400D35`：

```c
unsigned __int64 sub_400D35()
{
  unsigned __int64 result; // rax
  unsigned int v1; // [rsp+Ch] [rbp-24h]
  int i; // [rsp+10h] [rbp-20h]
  int j; // [rsp+14h] [rbp-1Ch]
  unsigned int v4; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v5; // [rsp+28h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  v1 = sub_43FD20(0LL) - qword_6CEE38;
  for ( i = 0; i <= 1233; ++i )
  {
    sub_40F790(v1);
    sub_40FE60();
    sub_40FE60();
    v1 = sub_40FE60() ^ 0x98765432;
  }
  v4 = v1;
  if ( ((unsigned __int8)v1 ^ byte_6CC0A0[0]) == 102 && (HIBYTE(v4) ^ (unsigned __int8)byte_6CC0A3) == 103 )
  {
    for ( j = 0; j <= 24; ++j )
      sub_410E90((unsigned __int8)byte_6CC0A0[j] ^ *((_BYTE *)&v4 + j % 4));
  }
  result = __readfsqword(0x28u) ^ v5;
  if ( result )
    sub_444020();
  return result;
}
```

继续跟进`sub_410E90`：

```c
__int64 __fastcall sub_410E90(unsigned int a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rdx
  _QWORD *v3; // rdi
  int v4; // eax
  unsigned __int64 v6; // r9
  bool v8; // zf
  _BYTE *v9; // rax
  __int64 v11; // rsi

  v1 = off_6CC820;
  v2 = a1;
  v3 = off_6CC820;
  if ( (*(_DWORD *)off_6CC820 & 0x8000) != 0 )
    goto LABEL_10;
  _R8 = *((_QWORD *)off_6CC820 + 17);
  v6 = __readfsqword(0x10u);
  if ( v6 == *(_QWORD *)(_R8 + 8) )
  {
    v3 = off_6CC820;
    goto LABEL_9;
  }
  _ESI = 1;
  v8 = dword_6CF29C == 0;
  if ( dword_6CF29C )
  {
    v4 = *(_DWORD *)off_6CC820 & 0x8000;
    if ( v4 == _InterlockedCompareExchange((volatile signed __int32 *)_R8, 1, v4) )
      goto LABEL_8;
    goto LABEL_7;
  }
  __asm { cmpxchg [r8], esi }
  if ( !v8 )
LABEL_7:
    sub_443B30(_R8, 1LL, v2);
LABEL_8:
  _R8 = v1[17];
  v3 = off_6CC820;
  *(_QWORD *)(_R8 + 8) = v6;
LABEL_9:
  ++*(_DWORD *)(_R8 + 4);
LABEL_10:
  v9 = (_BYTE *)v3[5];
  if ( (unsigned __int64)v9 >= v3[6] )
  {
    LODWORD(v2) = sub_415FE0(v3, (unsigned __int8)v2);
  }
  else
  {
    v3[5] = v9 + 1;
    *v9 = v2;
    LODWORD(v2) = (unsigned __int8)v2;
  }
  if ( (*(_DWORD *)v1 & 0x8000) != 0 )
    return (unsigned int)v2;
  v11 = v1[17];
  v8 = (*(_DWORD *)(v11 + 4))-- == 1;
  if ( !v8 )
    return (unsigned int)v2;
  *(_QWORD *)(v11 + 8) = 0LL;
  if ( dword_6CF29C )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)v11) )
      return (unsigned int)v2;
    goto LABEL_19;
  }
  v8 = (*(_DWORD *)v11)-- == 1;
  if ( !v8 )
LABEL_19:
    sub_443B60(v11);
  return (unsigned int)v2;
}
```

你逻辑写脚本，就解出来了flag：

```python
s = [0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F, 0x24, 0x6E, 0x62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E, 0x72, 0x3C, 0x32, 0x45, 0x5B]
s1 = 'flag'
flag = ''
key = ''
for i in range(4):
    key += chr(s[i] ^ ord(s1[i]))
for i in range(len(s)):
    flag += chr(s[i] ^ ord(key[i % 4]))
print(flag)
```

得到输出：

```text
flag{Act1ve_Defen5e_Test}
```